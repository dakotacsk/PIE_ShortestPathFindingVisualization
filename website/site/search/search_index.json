{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to PathFinders View in your space \ud83d\ude80 Discover the Future of Algorithmic Exploration \ud83d\ude80 PathFinder isn't just a game \u2014 it's an adventure into the world of pathfinding algorithm visualizations . Whether you're a gamer, a curious mind, or an educator, PathFinder brings the complex world of Q-learning and Dijkstra's to life in a way that's engaging, educational, and just plain fun. \ud83d\udcf8 Game Snapshots Take a sneak peek into the world of PathFinder! \ud83c\udfae Features Arcade-Style Gameplay : Immerse yourself in a hands-on learning experience with sleek visuals and intuitive controls. Interactive Algorithms : Visualize and interact with complex concepts like Dijkstra\u2019s Algorithm and Q-Learning through real-time simulations. Challenge Your Intellect : Test your problem-solving skills while learning about decision-making and optimization techniques. \ud83d\udee0\ufe0f Build Your Own Inspired to create something similar? We\u2019ve got you covered. Access our open-source resources and guides to make your own version of PathFinder: \ud83d\udcbe Download Game \ud83c\udf89 Join the Journey Stay updated with our latest features, contribute ideas, or just get to know the amazing team behind this. \ud83e\udd1d Meet the Team \ud83d\udc49 Follow us on GitHub","title":"Home"},{"location":"#welcome-to-pathfinders","text":"View in your space \ud83d\ude80 Discover the Future of Algorithmic Exploration \ud83d\ude80 PathFinder isn't just a game \u2014 it's an adventure into the world of pathfinding algorithm visualizations . Whether you're a gamer, a curious mind, or an educator, PathFinder brings the complex world of Q-learning and Dijkstra's to life in a way that's engaging, educational, and just plain fun.","title":"Welcome to PathFinders"},{"location":"download/","text":"Download for yourself to try! Download game Windows MacOS Linux Download source code from github > git clone https://github.com/dakotacsk/PIE_ShortestPathFindingVisualization > cd PIE_ShortestPathFindingVisualization","title":"Download!"},{"location":"download/#download-for-yourself-to-try","text":"","title":"Download for yourself to try!"},{"location":"team/","text":"Our team combines expertise in software development, mechanical engineering, and UI/UX design to bring PathFinder to life. Meet the passionate individuals behind the project: Dakota Role : Pathfinding Algorithm Specialist & UI/UX Designer Dakota is focused on understanding pathfinding algorithms, designing user-friendly interfaces, and creating physical demonstrations of abstract concepts. Vishnu Role : Raspberry Pi Integration & Pathfinding Algorithms Vishnu specializes in integrating software with Raspberry Pi, working on approachable UI design, and exploring pathfinding algorithms. Khoi Role : Mechanical-Software Bridge & Real-Time Visuals Khoi bridges the gap between mechanical and software components, creating real-time digital visuals and ensuring seamless integration. Chris Role : Mechanical, Electrical, and Software Design Integration Chris excels at integrating mechanical, electrical, and software designs into cohesive, functional systems inspired by 1980s arcade machines.","title":"Meet the Team"},{"location":"team/#meet-the-passionate-individuals-behind-the-project","text":"","title":"Meet the passionate individuals behind the project:"},{"location":"project/ece_firmware/","text":"ECE & Firmware Design Final Technical Overview Electrical Design Firmware Design Provide details on the firmware (e.g., Arduino logic), including tasks like LED control or input handling. PLACEHOLDER : Add firmware design description. Example Snippet : // Placeholder: LED Button Control Logic if (buttonPressed) { digitalWrite(LED_PIN, HIGH); } else { digitalWrite(LED_PIN, LOW); } Link to Source Code : PLACEHOLDER: Firmware Repo Link Analysis Document any relevant analysis of the mechanical or electrical systems, including: Stress analysis, simulations, or testing results for mechanical systems. Current, voltage, or signal flow analysis for electrical systems. Process Design Decisions Outline the major mechanical and electrical design choices made and why. Discuss alternatives considered and how time/budget constraints influenced the final design. Challenges Highlight challenges encountered in mechanical/electrical development and how they were resolved. Progress Timeline Provide a short timeline or milestones for mechanical/electrical progress.","title":"Firmware & ECE Process"},{"location":"project/ece_firmware/#ece-firmware-design","text":"","title":"ECE &amp; Firmware Design"},{"location":"project/meche/","text":"Mechanical Design Final Technical Overview Mechanical Design Description : Provide an overview of the mechanical components, including key design features and specifications. CAD Renderings : Insert CAD images or renderings here (or link to assets if applicable). Analysis Document any relevant analysis of the mechanical or electrical systems, including: Stress analysis, simulations, or testing results for mechanical systems. Current, voltage, or signal flow analysis for electrical systems. Process Design Decisions Outline the major mechanical and electrical design choices made and why. Discuss alternatives considered and how time/budget constraints influenced the final design. Challenges Highlight challenges encountered in mechanical/electrical development and how they were resolved. Progress Timeline Provide a short timeline or milestones for mechanical/electrical progress.","title":"Mechanical Process"},{"location":"project/meche/#mechanical-design","text":"","title":"Mechanical Design"},{"location":"project/project/","text":"Project Overview Table of Contents Budget and Components Media Mechanical Design Electrical and Firmware Design Software Design Energy Flow & System Diagrams Budget and Components Spending Breakdown Provide a table listing all components, their costs, and sources. PLACEHOLDER : Fill in actual component data in the table below. Component/Material Cost (USD) Source Example Component 1 $XX Example Source Example Component 2 Free (Estimated: $XX) Donated or Provided Example Component 3 $XX Purchased/Online Total Estimated Cost : PLACEHOLDER : Add total value. Media Final System in Action Add images and videos of the final project setup. PLACEHOLDER : Replace this with images and videos of your system in action. Example : Figure: Completed arcade machine showcasing the game. Demo Video Link to a video demo of the project. PLACEHOLDER : Add demo video link here. Example : Watch the Demo Video Final Designs Mechanical Design Provide a detailed description of the mechanical design, including materials, construction methods, and analysis. PLACEHOLDER : Add description of mechanical components. Include details on the design process, materials used, and fabrication methods. Describe any stress testing, simulations, or structural analysis performed. Replace this placeholder with relevant CAD images, renderings, or diagrams if available. Example : Figure: CAD rendering showing the structure and layout of the arcade machine. Design Highlights : Materials : Specify materials used (e.g., MDF, 3D-printed PLA, aluminum) and their purpose. Fabrication Methods : Describe how parts were cut, assembled, and finished (e.g., laser cutting, 3D printing, spray painting). Modularity : Explain how the design allows for future upgrades or ease of assembly. Analysis : Structural Analysis : Summarize results from stress tests or simulations to verify durability. User Interaction : Describe ergonomic considerations, such as button placement, screen height, and accessibility. Electrical and Firmware Design Provide a description of the electrical system, including connections, power requirements, and analysis. PLACEHOLDER : Add description of electrical components. Include details on power supply, wiring, and voltage/current analysis. Replace this placeholder with actual circuit diagrams and notes. Example : Figure: Circuit schematic showing connections between components. Software Design The software for Hatchling's Quest: Pathfinding Trials is designed to deliver an intuitive, engaging, and educational gaming experience while visualizing pathfinding algorithms in action. Software Architecture Software Structure and Key Modules Overview: The software is divided into three main areas: Game Interface : Handles the GUI, animations, and user input using Pygame . Pathfinding Algorithms : Dijkstra's Algorithm (Level 1): Computes shortest paths. Q-Learning (Level 2): Enables reward-based navigation. Game Logic : Manages screens, game states, and leaderboards. Key Modules: run_game.py : Coordinates game flow. grid/grid.py : Defines the pathfinding grid. Pathfinding Modules : sprites/DijkstraSprite.py : Implements Dijkstra\u2019s Algorithm. sprites/QLearningSprite.py : Implements Q-Learning. Screens : Main menu, instructions, and interactive gameplay feedback. Leaderboard : Tracks and displays high scores via leaderboard/leaderboard.py . Dependencies The software relies on the following external libraries: Python 3.11.7 : Core language used for development. NumPy (2.2.0) : Used for matrix operations in Q-Learning, including Q-table computations. Pygame (2.6.1) : Provides the framework for rendering the game interface and managing user input. Flow Diagram for Game The following flow diagram illustrates the architecture and flow of the game, showing transitions between levels, screens, and algorithms: Figure: Flow diagram representing game architecture and flow. UML Diagram The UML diagram below showcases the architecture and relationships within the game. It highlights key components, such as the flow between screens, sprite classes, and grid interactions, as well as how algorithms like Dijkstra's and Q-Learning are integrated: Figure: UML diagram representing the game architecture and component relationships. Link to Source Code The complete source code for the project is hosted on GitHub: GitHub Repo Link Process Design Decisions Outline the major mechanical and electrical design choices made and why. Discuss alternatives considered and how time/budget constraints influenced the final design. Challenges Highlight challenges encountered in mechanical/electrical development and how they were resolved. Progress Timeline Provide a short timeline or milestones for mechanical/electrical progress. Diagrams Data and Energy Flow Diagram Insert a high-level diagram showing how energy and data move through the system. PLACEHOLDER : Add data and energy flow diagram. Example : Figure: Data and energy flow in the arcade system. Subsystem Diagrams Include additional diagrams that illustrate subsystem connections or component relationships. PLACEHOLDER : Add subsystem diagrams (e.g., mechanical, electrical, or software). Example : Figure: Subsystem relationships across hardware, software, and firmware. Conclusion PLACEHOLDER : Add a brief conclusion summarizing the project's success, challenges overcome, and key learnings.","title":"Final Overview"},{"location":"project/project/#project-overview","text":"","title":"Project Overview"},{"location":"project/software/","text":"Table of Contents Sprint 1 Sprint 2 Narrative Ideations Process Sprint 1 Our goal was to build a proof of concept with: A functional grid system . A Dijkstra agent that: Prioritizes green reward blocks . Avoids red punishment blocks . Testing Pygame as the main library. Early progress on the Q-Learning agent . Teaching users the difference between Dijkstra\u2019s Algorithm and Q-Learning . Challenges and Design Decisions 1. External Libraries vs. Customizability Why : Existing libraries (e.g., Gym) ran in their own environments and were hard to customize. Decision : Full control over sprites and mechanics for flexibility. Pivot : Develop modular tools to speed up development without losing control. 2. Teaching Dijkstra vs. Q-Learning Challenge : The two algorithms are too different for straightforward comparison. Struggle : Aligning gameplay and storyline to highlight their unique applications. Pivot : Refocus the storyline to show how each algorithm solves unique problems instead of directly comparing them. 3. Mechanics Development Issue : Without external libraries, we\u2019re spending significant time on foundational mechanics. Pivot : Use lightweight tools (e.g., GUI libraries) to improve efficiency without losing control. 4. Playtesting Barriers Problem : The game feels too technical for players without RL knowledge . Pivot : Add visual aids (e.g., overlays, step-by-step explanations) to teach key mechanics. Simplify early levels for intuitive gameplay. 5. Grid Size and Performance Challenge : Larger grids stress GPU/CPU resources and increase training time. Why not pre-train? : Real-time, dynamic training is a key feature. Pivot : Start with smaller grids and scale gradually. Optimize Q-Learning to reduce computational overhead. 6. Storyline Integration Issue : Tying gameplay, RL mechanics, and a compelling storyline is difficult. Pivot : Simplify the narrative to focus on goal-driven challenges where each algorithm\u2019s strengths shine. Sprint 2 For Sprint 2, we focused on graphics, gameplay tweaks , and building an MVP styled as an old arcade game . 1. Q-Learning Enhancements Fully functional Q-Learning sprite . Real-time Q-Table Visualization for intuitive learning feedback. 2. User Interface Functional Home Page and two Instruction Screens : Simple gameplay explanation. Overview of Dijkstra\u2019s Algorithm and Q-Learning . Added a Credits Screen with consistent styling. 3. Gameplay Feedback On-screen messages show: Current step of the Q-Learning sprite. Progress out of 5000 max steps . 4. Visual Updates Adjusted to a horizontal layout for arcade monitor compatibility. Limited controls to 6 buttons for simplicity. 5. Scrolling Text Standardized scrolling text animations with a base class . 6. Leaderboard Screen Added a non-functional leaderboard screen (debugging in progress). 7. Explanation Screen Added screens to explain sprite oscillation and invalid moves during Q-Learning. Challenges and Potential Pivots 1. Storyline Development Issue : We still struggle to develop a cohesive storyline. Pivot : Use the Dijkstra sprite as a tutorial to introduce mechanics. Simplify the narrative into progression-based challenges . 2. Q-Table Display Issue : Q-Table numbers overlap, creating clutter. Fix : Tweak reward/punishment values. Round displayed Q-table numbers for clarity. 3. Leaderboard Issues Issue : Leaderboard functionality is incomplete. Fix : Debug and finalize leaderboard tracking for high scores. 4. Max Steps Taking Too Long Issue : 5000 steps feel excessive and slow down gameplay. Pivot : Allow users to adjust step sizes (e.g., 100, 500, 1000). Streamline gameplay to reduce unnecessary steps. 5. Gameplay Consistency Issue : The game doesn\u2019t always behave as expected. Fix : Perform a parameter sweep to balance rewards, punishments, and grid size. Ensure consistent gameplay that\u2019s challenging but winnable . Narrative Ideations In Sprint 2, we explored potential storylines to align gameplay with engaging narratives. 1. Car Game Concept : A car loses gas with each step. Red squares : Obstacles increasing gas loss. Green squares : Gas stations for refueling. Fix : Dijkstra : Efficient route to gas stations. Q-Learning : Adaptive navigation to avoid obstacles. 2. Park Game Concept : Park-goers navigate delays and rewards. Red squares : Monuments or benches. Green squares : Fields requiring maintenance. Fix : Dijkstra : Optimized static pathfinding. Q-Learning : Adapts dynamically to new obstacles. 3. Immigrant Boat Game Concept : Escape threats while maintaining morale. Green squares : Safe havens. Red squares : Pirates reducing morale. Fix : Dijkstra : Safest, most optimal path. Q-Learning : Learns dynamically to avoid threats. Next Steps Select and integrate a streamlined narrative . Align rewards and punishments with storyline progression. Optimize mechanics to balance user engagement and educational value . Here\u2019s Sprint 3 formatted cleanly and consistently with your earlier sections: Sprint 3 Narrative Ideation We settled on a storyline where baby turtles must find their way to the ocean after hatching. The game aims to: Educate users on reinforcement learning algorithms . Teach users about the natural behavior of turtle hatchlings. Spread awareness on the issue of light pollution and its impact on nature. Final Updates Sprite images added! Storyline integrated into the gameplay. Bugs fixed to improve robustness. Option to choose max steps added for better gameplay flexibility. File reorganization completed to prepare for a downloadable app . Challenges and Pivots At this stage, the primary focus is on: Pivot : Finishing the final touches and fixing all remaining bugs to ensure the game is robust and ready for release. You can see the final results in the project overview! Alternatively, feel free to play the game using the download page.","title":"Software Process"},{"location":"project/software/#process","text":"","title":"Process"}]}